/*
 * Copyright and related rights waived via CC0
 *
 * You should have received a copy of the CC0 legalcode along with this
 * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */


plugins {
    id 'org.graalvm.internal.tck-base'
    id 'checkstyle'
    id 'java-library'
    id 'org.graalvm.buildtools.native'
}

repositories {
    mavenLocal()
    mavenCentral()
}

tasks.withType(JavaCompile).configureEach {
    options.release = 17
}

checkstyle {
    configFile tck.repoRoot.file("gradle/checkstyle.xml").get().asFile
}

tasks.register("checkstyle") {
    description = "Runs all checkstyle tasks"
    group = JavaBasePlugin.VERIFICATION_GROUP
    dependsOn tasks.withType(Checkstyle)
}

tasks.withType(Checkstyle).configureEach {
    exclude {
        it.file.absolutePath.contains('generated')
    }
}

String metadataPath = Objects.requireNonNullElse(
		System.getenv("GVM_TCK_MD"),
		providers.gradleProperty('metadata.dir').get()
)

String libraryVersion = System.getenv("GVM_TCK_LV") ?: providers.gradleProperty('library.version').get()

String libraryGAV = System.getenv("GVM_TCK_LC") ?: providers.gradleProperty('library.coordinates').getOrElse(null)
libraryGAV = libraryGAV ?: ""

String overrideVal = System.getenv("GVM_TCK_EXCLUDE") ?: providers.gradleProperty('library.override').getOrElse(null)
overrideVal = overrideVal ?: "false"
boolean override = overrideVal.toBoolean()

tck.testedLibraryVersion = libraryVersion
// This value can be used to request specific library version to test with.

dependencies {
    testImplementation(platform(libs.test.junit.bom))
    testImplementation(libs.test.junit.jupiter.core)
    testImplementation(libs.test.junit.vintage)
}

tasks.named('test') {
    useJUnitPlatform()
    testLogging {
        exceptionFormat = 'full'
        showStackTraces = true
    }
}

def obfuscatedClasspathProvider = project.objects.property(FileCollection)

task processAgentOutput {
    mustRunAfter tasks.named("generateTestResourcesConfigFile")

    outputs.upToDateWhen { false }
    
    doLast {
        println "=== Starting Agent Output Processing ==="
        
        def agentOutputDir = file("${buildDir}/resources/test/META-INF/native-image/test")
        println "Looking for agent output in: ${agentOutputDir.absolutePath}"
        
        def proguardMapperScript = file("${rootProject.projectDir}/../../../../../proguard_mapper/proguard_mapper.py")
        def proguardConfigOutput = file("${buildDir}/proguard-config.pro")

        def result = exec {
            executable "python3"
            args proguardMapperScript.absolutePath, 
                    agentOutputDir.absolutePath,
                    proguardConfigOutput.absolutePath
            ignoreExitValue = false
        }

        if (result.exitValue != 0) {
            println "ERROR: non-zero exit code from proguard mapping script"
        }

        println "ProGuard config generated at: ${proguardConfigOutput.absolutePath}"
        println "ProGuard config content:"
        println proguardConfigOutput.text

        // TODO: the classpath entries we skip must still be part of the classpath we inject into NI.

        def nativeClasspath = project.files(
            // Base test classpath (filter out main classes)
            tasks.named("test").get().classpath.filter { 
                file(it.absolutePath).exists() &&
                // Skip testing framework 
                !it.absolutePath.contains("junit") && 
                !it.absolutePath.contains("hamcrest-core") && 
                !it.absolutePath.contains("assertj-core") && 
                !it.absolutePath.contains("opentest4j") // it.absolutePath.contains("build/classes/java/main") || it.absolutePath.contains("build/resources/main") || 
            },
            // Additional native-image specific paths
            // "${buildDir}/classes/java/test",
            // "${buildDir}/classes/java/test",
            // "${buildDir}/resources/test",  
            // "${buildDir}/test-results/test/testlist",
            // "${buildDir}/libs/org.liquibase.liquibase-core_tests.jar",
        )
        println "Native classpath entries:"
        nativeClasspath.each { path ->
            println "${path.absolutePath}"
        }

        // === Execute ProGuard ===
        // Create output directory for obfuscated jars
        def obfuscatedDir = file("${buildDir}/obfuscated-jars")
        obfuscatedDir.mkdirs()

        def proguardArgs = [
            "@${proguardConfigOutput.absolutePath}"
        ]

        // Add input-output jar pairs. 
        // We don't want to create fat jar since then we cannot keep the manifest files.
        nativeClasspath.each { inputPath ->
            def randomPrefix = UUID.randomUUID().toString().take(8)
            def outputPath = new File(obfuscatedDir, randomPrefix + "_" + inputPath.name)
            proguardArgs.addAll([
                "-injars", inputPath.absolutePath,
                "-outjars", outputPath.absolutePath
            ])
        }

        println "Executing proguard with args: ${proguardArgs}"
        proguardArgs.each { arg -> 
            println " - ${arg}"
        }
        def proguardScript = "/Users/joelrudsberg/Software/proguard-7.6.0/bin/proguard.sh"
        def proguardResult = exec {
            executable proguardScript
            args proguardArgs
            ignoreExitValue = true // should be false 
            // maybe not needed 
            environment('PROGUARD_OPTS', '-Xmx10G -XX:MaxMetaspaceSize=4000M')
            environment('GRADLE_OPTS', '-Xmx6000m')
        }
        
        if (proguardResult.exitValue == 0) {
            println "ProGuard execution successful. Saved to ${obfuscatedDir}"
            println "Setting obfuscated class path..."
            project.setObfuscatedClasspath(project.files(obfuscatedDir.listFiles()))
        } else {
            println "ERROR: ProGuard execution failed!"
        }
        
        println "=== Completed Agent Output Processing ==="
    }
}

graalvmNative {
    metadataRepository {
        enabled = true
        uri(tck.metadataRoot.get().asFile)
    }
    binaries {
        test {
            if (override) {
                excludeConfig.put(libraryGAV, [".*"])
            }
            buildArgs.add('-H:+StrictConfiguration') // Necessary in order to test metadata properly
            // TODO: this appends to classpath, and since the original compiled sources are also on the classpath, they
            // will get picked first... So for now I did a hack were I reverse the classpath string in NI. 
            println "\nSetting NI classpath to:"
            classpath = obfuscatedClasspathProvider.getOrNull()?.files ?: ["FAILED"]
            classpath.each { arg -> 
                println " - " + arg
            }
            setNIClasspath(providers.provider { classpath })
            verbose = true
            quickBuild = true
        }
    }
}

tasks.named("nativeTestCompile") {
    dependsOn processAgentOutput
    doNotTrackState("becuase of dynamic obfuscatedClasspathProvider") 
}

project.ext.setObfuscatedClasspath = { FileCollection files ->
    obfuscatedClasspathProvider.set(files)
}
