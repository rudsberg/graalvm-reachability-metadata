/*
 * Copyright and related rights waived via CC0
 *
 * You should have received a copy of the CC0 legalcode along with this
 * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */

plugins {
    id 'org.graalvm.internal.tck-base'
    id 'checkstyle'
    id 'java-library'
    id 'org.graalvm.buildtools.native'
}

repositories {
    mavenLocal()
    mavenCentral()
}

tasks.withType(JavaCompile).configureEach {
    options.release = 17
}

checkstyle {
    configFile tck.repoRoot.file("gradle/checkstyle.xml").get().asFile
}

tasks.register("checkstyle") {
    description = "Runs all checkstyle tasks"
    group = JavaBasePlugin.VERIFICATION_GROUP
    dependsOn tasks.withType(Checkstyle)
}

tasks.withType(Checkstyle).configureEach {
    exclude {
        it.file.absolutePath.contains('generated')
    }
}

String metadataPath = Objects.requireNonNullElse(
		System.getenv("GVM_TCK_MD"),
		providers.gradleProperty('metadata.dir').get()
)

String libraryVersion = System.getenv("GVM_TCK_LV") ?: providers.gradleProperty('library.version').get()

String libraryGAV = System.getenv("GVM_TCK_LC") ?: providers.gradleProperty('library.coordinates').getOrElse(null)
libraryGAV = libraryGAV ?: ""

String overrideVal = System.getenv("GVM_TCK_EXCLUDE") ?: providers.gradleProperty('library.override').getOrElse(null)
overrideVal = overrideVal ?: "false"
boolean override = overrideVal.toBoolean()

tck.testedLibraryVersion = libraryVersion
// This value can be used to request specific library version to test with.

dependencies {
    testImplementation(platform(libs.test.junit.bom))
    testImplementation(libs.test.junit.jupiter.core)
    testImplementation(libs.test.junit.vintage)
}

tasks.named('test') {
    useJUnitPlatform()
    testLogging {
        exceptionFormat = 'full'
        showStackTraces = true
    }
}

def obfuscatedClasspathProvider = project.objects.property(FileCollection)

task processAgentOutput {
    mustRunAfter tasks.named("generateTestResourcesConfigFile")

    outputs.upToDateWhen { false }
    
    doLast {
        println "=== Starting Agent Output Processing ==="
        def graalvmHome = System.getenv('GRAALVM_HOME')
        if (!graalvmHome) {
            throw new GradleException("GRAALVM_HOME env variable must be set")
        }
        def jmodsDir = new File("${graalvmHome}/jmods")
        if (!jmodsDir) {
            throw new GradleException("${jmodsDir.absolutePath} not found")
        }
        def libraryJars = []
        jmodsDir.listFiles().each { file -> 
            if (file.absolutePath.endsWith(".jmod")) {
                libraryJars.add("-libraryjars ${file.absolutePath}")
            }
        }
        
        def agentOutputDir = file("${buildDir}/resources/test/META-INF/native-image")
        println "Looking for agent output in: ${agentOutputDir.absolutePath}"
        
        def proguardMapperScript = file("${rootProject.projectDir}/../../../../../proguard_mapper/proguard_mapper.py")
        def proguardConfigOutput = file("${buildDir}/proguard-config.pro")

        def result = exec {
            executable "python3"
            args proguardMapperScript.absolutePath, 
                    agentOutputDir.absolutePath,
                    proguardConfigOutput.absolutePath
            ignoreExitValue = false
        }

        if (result.exitValue != 0) {
            println "ERROR: non-zero exit code from proguard mapping script"
        }

        println "ProGuard config generated at: ${proguardConfigOutput.absolutePath}"
        println "ProGuard config content:"
        println proguardConfigOutput.text

        println "testClasses classpath:"
        project.files(
            tasks.named("test").get().classpath.each { path ->
                println " - " + path
            }
        )

        // We shouldn't obfuscate the 
        def classPathsToObfuscate = []
        def classPathsNotToObfuscate = []
        tasks.named("test").get().classpath.each { path -> 
            def absPath = path.absolutePath
            def shouldObfuscate = !absPath.contains("junit") && 
                !absPath.contains("hamcrest-core") && 
                !absPath.contains("assertj-core") && 
                !absPath.contains("opentest4j") &&
                !absPath.contains("apiguardian") &&
                !absPath.contains("resources/test") &&
                file(absPath).exists()
            if (shouldObfuscate) {
                classPathsToObfuscate.add(path)
            } else {
                classPathsNotToObfuscate.add(path)
            }
        }

        println "Class paths to obfuscate:"
        classPathsToObfuscate.each { path ->
            println "${path.absolutePath}"
        }
        println "Class paths to NOT obfuscate:"
        classPathsNotToObfuscate.each { path ->
            println "${path.absolutePath}"
        }

        // === Execute ProGuard ===
        // Create output directory for obfuscated jars
        def obfuscatedDir = file("${buildDir}/obfuscated-jars")
        obfuscatedDir.mkdirs()
        def mappingFileName = "mapping.txt"
        def proguardArgs = [
            "@${proguardConfigOutput.absolutePath}",
            // TODO: need to add svm runtime as library jar to get rid of warnings "-libraryjars",
            // how does mx do that? 
            "-printmapping ${mappingFileName}",
            "-ignorewarning",
            // TODO: hardcoding - cannot obfuscate junit classes/methods, OR we can but the must update the junit list that is generated
            "-keep class com_test.obfuscation.ObfuscationTest",
            
            "-keep class ch_qos_logback_contrib.logback_jackson.LogbackJacksonTest",
            "-keep class ch.qos.logback.core.ConsoleAppender",
            "-keep class ch.qos.logback.core.encoder.LayoutWrappingEncoder",
            "-keep class ch.qos.logback.contrib.json.classic.JsonLayout",
            "-keep class ch.qos.logback.contrib.jackson.JacksonJsonFormatter",
            
            "-keepattributes Module*",
            "-keep class module-info",

            *libraryJars
        ]

        // Add input-output jar pairs. 
        // We don't want to create fat jar since then we cannot keep the manifest files.
        def obfuscatedDirectories = [] // project.files(obfuscatedDir.listFiles())
        classPathsToObfuscate.each { inputPath ->
            def randomPrefix = UUID.randomUUID().toString().take(8)
            def outputPath = new File(obfuscatedDir, randomPrefix + "_" + inputPath.name)
            obfuscatedDirectories.add(outputPath)
            proguardArgs.addAll([
                "-injars", inputPath.absolutePath,
                "-outjars", outputPath.absolutePath
            ])
        }
        def projectFiles = project.files(obfuscatedDir.listFiles()).filter { path ->
            !path.absolutePath.contains("obfuscatedDir")
        }

        println "Executing proguard with args: ${proguardArgs}"
        proguardArgs.each { arg -> 
            println " - ${arg}"
        }
        def proguardScript = "/Users/joelrudsberg/Software/proguard-7.6.0/bin/proguard.sh"
        def proguardResult = exec {
            executable proguardScript
            args proguardArgs
            ignoreExitValue = true // should be false 
            // maybe not needed 
            environment('PROGUARD_OPTS', '-Xmx10G -XX:MaxMetaspaceSize=4000M')
            environment('GRADLE_OPTS', '-Xmx6000m')
        }
        
        if (proguardResult.exitValue == 0) {
            println "ProGuard execution successful. Saved to ${obfuscatedDir}"
            println "Setting obfuscated class path:"
            def finalClasspath = classPathsNotToObfuscate + obfuscatedDirectories + projectFiles
            println "Final classpath:"
            finalClasspath.each { arg ->
                println " - ${arg}"
            }
            project.graalvmNative.binaries.test.setNIClasspath(finalClasspath)
        } else {
            println "ERROR: ProGuard execution failed!"
        }
        
        println "=== Completed Agent Output Processing ==="
    }
}

graalvmNative {
    metadataRepository {
        enabled = true
        uri(tck.metadataRoot.get().asFile)
    }
    binaries {
        test {
            if (override) {
                excludeConfig.put(libraryGAV, [".*"])
            }
            buildArgs.add('-H:+StrictConfiguration') // Necessary in order to test metadata properly
            verbose = true
            quickBuild = true
        }
    }
}

tasks.named("nativeTestCompile") {
    dependsOn processAgentOutput
    doNotTrackState("becuase of dynamic obfuscatedClasspathProvider") 
}

project.ext.setObfuscatedClasspath = { FileCollection files ->
    obfuscatedClasspathProvider.set(files)
}
